<div class="atSection atYAML">
  <h1 class="atSectionTitle">YAML</h1>
  <p>
    Having a uniform system to interchange binary data is nice, but we musn't forget
    the human programmers that work with the data and design systems around it.
    This is where having a textual representation of the structured data is convenient.
    <a href="https://en.wikipedia.org/wiki/YAML">YAML</a> is a simplistic data-serialization
    format, capable of organizing string-representations of data members into mappings and 
    sequences with multiple levels of hierarchy. 
  </p>
  <p>
    <a href="">Athena::io::DNA</a> has been subclassed as <a href="">Athena::io::DNAYaml</a> 
    to have ATDNA generate YAML serialization/deserialization alongside the binary readers/writers.
    It's used just like the DNA system from the developer's perspective.
  </p>

  <div class="atIDE">
    <h1>YAMLDemo.hpp</h1>
{% athighlight c++ %}
#include <Athena/DNAYaml.hpp>
using BigYAML = Athena::io::DNAYaml<Athena::BigEndian>;

struct MyYAMLRecord : BigYAML
{
    /* This macro declares required member functions implementing the 
     * YAML record (generated by ATDNA and linked as a separate .cpp file) */
    DECL_YAML

    /* Value<T> template passes T though to the compiler and 
     * exposes the field to ATDNA. Primitive fields without Value<T>
     * are ignored by ATDNA. */
    Value<atUint32> m_val1;
    Value<float> m_val2;
    Value<atVec3f> m_val3;

    /* Nested record declartions are also processed by ATDNA, 
     * assisting multi-level nested reads/writes */
    struct MyYAMLSubRecord : BigYAML
    {
        DECL_YAML
        Value<atUint32> m_subVal;
    };

    /* Vector<T,DNA_COUNT(N)> template wraps a std::vector containing 
     * N elements of type T. N is captured as a full C++ expression by the 
     * DNA_COUNT macro and pasted within the YAML record implementation. */
    Value<atUint32> m_subCount;
    Vector<MyYAMLSubRecord, DNA_COUNT(m_subCount)> m_subObjs;
};
{% endathighlight %}
  </div>

  <p>
    Now applications can use YAML as a data source/destination in addition to the
    orginal binary format the DNA is based on. Such YAML may look like this:
  </p>
  <div class="atIDE">
    <h1>YAMLDemo.yaml</h1>
{% athighlight yaml %}
m_val1: 0x42
m_val2: 3.14159265359
m_val3: [1.000000, 2.000000, 3.000000]
m_subCount: 0x3
m_subObjs:
- {m_subVal: 0x1}
- {m_subVal: 0x2}
- {m_subVal: 0x3}
{% endathighlight %}
  </div>

  <h2>All together now!</h2>
  <p>
    The YAML implementations are compiled side-by-side with the DNA implementations.
    The application may invoke them in a similar manner:
  </p>
  <div class="atIDE">
    <div class="atReadLayer">
      <h1>main.cpp</h1>
{% athighlight c++ %}
#include <stdio.h>
#include <iostream>
#include "YAMLDemo.hpp"
int main(int argc, char* argv[])
{
    /* Stdio FILEs are one option. Raw string buffers are also available */
    FILE* fp = fopen("MyDemoYAML.yaml", "r");
    MyYAMLRecord record;
    record.fromYAMLFile(fp); /* YAML implementation called here */
    std::cout << "Val1: " << record.m_val1 << " Val2: " << record.m_val2 << "\n";
}

{% endathighlight %}
    </div>
    <div class="atWriteLayer">
      <h1>main.cpp</h1>
{% athighlight c++ %}
#include <stdio.h>
#include <iostream>
#include "YAMLDemo.hpp"
int main(int argc, char* argv[])
{
    /* Stdio FILEs are one option. Raw string buffers are also available */
    FILE* fp = fopen("MyDemoYAML.yaml", "w");
    MyYAMLRecord record;
    record.m_val1 = 0x42;
    record.m_val2 = 3.14159265359;
    record.toYAMLFile(fp); /* YAML implementation called here */
}

{% endathighlight %}
    </div>
  </div>
  
</div>