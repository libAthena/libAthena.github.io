<div class="atSection atDNA">
  <h2 class="atSectionTitle">DNA</h2>
  <p>
    Loading data field-by-field with Athena's Core has some benefits: It provides
    a sensible place to convert endian (byte-order) for numeric types.
    It can be made to handle compound types. The backing buffer is
    tightly-packed for compact storage (no need to worry about 
    SIMD-alignment once read).
  </p>

  <p>
    The major drawback is inconvenience; code needs to be written to
    map the data structure's fields to segments in the streamed buffer.
  </p>
  
  <h3>ATDNA: Athena's Copilot</h3>
  <p>
    Athena ships with a build-tool called <code>atdna</code> that transforms C++ record 
    declarations (i.e. structs, classes, unions) into reader/writer implementations
    <em>automatically</em>. When properly integrated into a project's build system,
    changes made to the C++ records will trigger these implementations to update
    along with the project.
  </p>

  <p>
    Special template types are provided by <a href="">Athena::io::DNA</a> to
    produce a well-defined <em>DNA Record</em>.
  </p>
  <div class="atIDE">
    <h1>DNADemo.hpp</h1>
{% athighlight c++ %}
#include <Athena/DNA.hpp>
using BigDNA = Athena::io::DNA<Athena::BigEndian>;

struct MyDNARecord : BigDNA
{
    /* This macro declares required member functions implementing the 
     * DNA record (generated by ATDNA and linked as a separate .cpp file) */
    DECL_DNA

    /* Value<T> template passes T though to the compiler and 
     * exposes the field to ATDNA. Primitive fields without Value<T>
     * are ignored by ATDNA. */
    Value<atUint32> m_val1;
    Value<float> m_val2;
    Value<atVec3f> m_val3;

    /* Nested record declartions are also processed by ATDNA, 
     * assisting multi-level nested reads/writes */
    struct MyDNASubRecord : BigDNA
    {
        DECL_DNA
        Value<atUint32> m_subVal;
    };

    /* Vector<T,DNA_COUNT(N)> template wraps a std::vector containing 
     * N elements of type T. N is captured as a full C++ expression by the 
     * DNA_COUNT macro and pasted within the DNA record implementation. */
    Value<atUint32> m_subCount;
    Vector<MyDNASubRecord, DNA_COUNT(m_subCount)> m_subObjs;
};
{% endathighlight %}
  </div>

  <p>
    Once the record has been defined in a header file, the header is passed
    to <code>atdna</code> whenever it changes. It uses
    <a href="http://clang.llvm.org/docs/Tooling.html">libclang</a> 
    to decompose the header into C++ declarations and emits the appropriate
    read/write functions according to the field types.
  </p>

</div>